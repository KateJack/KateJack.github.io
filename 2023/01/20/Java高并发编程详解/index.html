<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>Java 高并发编程详解 [ 洪志鑫技术博客 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

<meta name="generator" content="Hexo 6.3.0"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">Java 高并发编程详解</h1>
<article class="post markdown-style">
  <h1 id="Java-高并发编程详解"><a href="#Java-高并发编程详解" class="headerlink" title="Java 高并发编程详解"></a>Java 高并发编程详解</h1><h2 id="第一部分-多线程基础"><a href="#第一部分-多线程基础" class="headerlink" title="第一部分 多线程基础"></a>第一部分 多线程基础</h2><h3 id="第一章-快速认识线程"><a href="#第一章-快速认识线程" class="headerlink" title="第一章 快速认识线程"></a>第一章 快速认识线程</h3><h5 id="尝试并行运行"><a href="#尝试并行运行" class="headerlink" title="尝试并行运行"></a>尝试并行运行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TryConcurrency</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        browserNews();<span class="comment">//在main方法中调用浏览新闻和听音乐但是由于无限循环，程序的输出结果只有浏览新闻</span></span><br><span class="line">        enjoyMusic();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enjoyMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;<span class="comment">//无限循环</span></span><br><span class="line">            System.out.println(<span class="string">&quot;the nice music&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(i);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">browserNews</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;the good news&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//使用匿名内部类的方法创建线程，重写run方法</span></span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                enjoyMusic();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        browserNews();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>两个方法，其中一个交给Thread即可实现并发执行交替输出。</p>
<h5 id="start方法源码"><a href="#start方法源码" class="headerlink" title="start方法源码"></a>start方法源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)<span class="comment">//判断线程是否是NEW状态</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">         * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;<span class="comment">//不能两次启动线程</span></span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">start0()方法是JNI方法，在start()中调用start0()方法,方法run是被start0()调用的。</span><br></pre></td></tr></table></figure>

<ol>
<li>Thread构造后的NEW状态，实际上<code>threadStatus</code>这个内部属性为0。</li>
<li>不能两次启动线程。</li>
<li>一个线程生命周期结束后，到达TERMINATED状态，不允许再次调用start方法。TERMINATED状态无法回到RUNNABLE&#x2F;RUNNING状态。</li>
</ol>
<h4 id="三种线程创建方式"><a href="#三种线程创建方式" class="headerlink" title="三种线程创建方式"></a>三种线程创建方式</h4><h5 id="继承Thread类并重写run方法"><a href="#继承Thread类并重写run方法" class="headerlink" title="继承Thread类并重写run方法"></a>继承Thread类并重写run方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;extends Thread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="type">MyTread</span> <span class="variable">myTread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTread</span>();</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        myTread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="实现Runnable接口的run方法"><a href="#实现Runnable接口的run方法" class="headerlink" title="实现Runnable接口的run方法"></a>实现Runnable接口的run方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RunnableTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Runnable Task&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTask</span>();</span><br><span class="line">        myTask.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="使用FutureTask方式"><a href="#使用FutureTask方式" class="headerlink" title="使用FutureTask方式"></a>使用<code>FutureTask</code>方式</h5><h3 id="第二章-深入理解Thread构造函数"><a href="#第二章-深入理解Thread构造函数" class="headerlink" title="第二章 深入理解Thread构造函数"></a>第二章 深入理解Thread构造函数</h3><h4 id="线程命名"><a href="#线程命名" class="headerlink" title="线程命名"></a>线程命名</h4><p>Thread有些构造方法中没有为Thread提供命名的参数，线程会以Thread-为前缀与一个自增数字进行组合。</p>
<p>有些构造方法中会有线程命名的参数</p>
<p>所有的线程在线程启动前可以对线程命名进行修改，如果线程启动那么对线程命名的修改无效。</p>
<h4 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a><code>ThreadGroup</code></h4><p>可以显式的指定线程的Group也可以直接加入到父线程所在的线程组。</p>
<h4 id="Thread和Runnable"><a href="#Thread和Runnable" class="headerlink" title="Thread和Runnable"></a><code>Thread</code>和<code>Runnable</code></h4><p>Thread负责线程本身相关的职责控制，<code>Runnable</code>负责逻辑执行单元。</p>
<h4 id="stackSize"><a href="#stackSize" class="headerlink" title="stackSize"></a><code>stackSize</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 守护线程</span><br><span class="line"></span><br><span class="line">一类特殊的线程，一般用于处理后台工作，比如垃圾回收线程。</span><br><span class="line"></span><br><span class="line">JVM程序在没有一个非守护线程的时候退出。</span><br><span class="line"></span><br><span class="line">### 第三章Thread API</span><br><span class="line"></span><br><span class="line">	#### 线程sleep</span><br><span class="line"></span><br><span class="line">sleep方法会使当前线程进入指定 时间的休眠，暂停执行。休眠不会放弃monitor锁的所有权。</span><br><span class="line"></span><br><span class="line">##### ```TimeUnit```枚举</span><br><span class="line"></span><br><span class="line">在jdk1.5之后，引入```TimeUnit```枚举对sleep方法进行很好的封装，使用```TimeUnit```可以省去休眠时间毫秒数纳秒数的换算。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">TimeUnit.HOURS.sleep(3);</span><br><span class="line">TimeUnit.MINUTES.sleep(24);</span><br><span class="line">TimeUnit.SECONDS.sleep(17);</span><br><span class="line">TimeUnit.MILLISECONDS.sleep(88);</span><br><span class="line"></span><br><span class="line">//Tread.sleep(12257088L);</span><br></pre></td></tr></table></figure>

<p>以下是<code>TimeUnit</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs a &#123;<span class="doctag">@link</span> Thread#sleep(long, int) Thread.sleep&#125; using</span></span><br><span class="line"><span class="comment">     * this time unit.</span></span><br><span class="line"><span class="comment">     * This is a convenience method that converts time arguments into the</span></span><br><span class="line"><span class="comment">     * form required by the &#123;<span class="doctag">@code</span> Thread.sleep&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the minimum time to sleep. If less than</span></span><br><span class="line"><span class="comment">     * or equal to zero, do not sleep at all.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while sleeping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ms</span> <span class="operator">=</span> toMillis(timeout);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> excessNanos(timeout, ms);</span><br><span class="line">            Thread.sleep(ms, ns);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time unit representing one second</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SECONDS &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toNanos</span><span class="params">(<span class="type">long</span> d)</span>   &#123; <span class="keyword">return</span> x(d, C3/C0, MAX/(C3/C0)); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toMicros</span><span class="params">(<span class="type">long</span> d)</span>  &#123; <span class="keyword">return</span> x(d, C3/C1, MAX/(C3/C1)); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toMillis</span><span class="params">(<span class="type">long</span> d)</span>  &#123; <span class="keyword">return</span> x(d, C3/C2, MAX/(C3/C2)); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toSeconds</span><span class="params">(<span class="type">long</span> d)</span> &#123; <span class="keyword">return</span> d; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toMinutes</span><span class="params">(<span class="type">long</span> d)</span> &#123; <span class="keyword">return</span> d/(C4/C3); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toHours</span><span class="params">(<span class="type">long</span> d)</span>   &#123; <span class="keyword">return</span> d/(C5/C3); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">toDays</span><span class="params">(<span class="type">long</span> d)</span>    &#123; <span class="keyword">return</span> d/(C6/C3); &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">convert</span><span class="params">(<span class="type">long</span> d, TimeUnit u)</span> &#123; <span class="keyword">return</span> u.toSeconds(d); &#125;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">excessNanos</span><span class="params">(<span class="type">long</span> d, <span class="type">long</span> m)</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="线程yield"><a href="#线程yield" class="headerlink" title="线程yield"></a>线程yield</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### sleep 和yield</span><br><span class="line"></span><br><span class="line">一个线程sleep另一个线程调用interrupt会捕获到中断信号，yield不会。</span><br><span class="line"></span><br><span class="line">#### 线程优先级</span><br><span class="line"></span><br><span class="line">在CPU比较忙的时候优先级高的先执行，但是在CPU空闲的时候不一定按照优先级的高低顺序执行。</span><br><span class="line"></span><br><span class="line">线程优先级范围1-10，如果设置优先级大于所在group的优先级，设置的优先级大小为所在线程group的优先级最大值。</span><br><span class="line"></span><br><span class="line">一般情况下不会设定线程的优先级，更不会让某些业务严重的依赖线程的优先级设定某个业务的权重，这种方法不可取，一般使用线程的默认优先级即可（5）。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public final void setPriority(int newPriority) &#123;</span><br><span class="line">        ThreadGroup g;</span><br><span class="line">        checkAccess();</span><br><span class="line">        if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        if((g = getThreadGroup()) != null) &#123;</span><br><span class="line">            if (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">                newPriority = g.getMaxPriority();</span><br><span class="line">            &#125;</span><br><span class="line">            setPriority0(priority = newPriority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The minimum priority that a thread can have.</span><br><span class="line">     */</span><br><span class="line">    public final static int MIN_PRIORITY = 1;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">     * The default priority that is assigned to a thread.</span><br><span class="line">     */</span><br><span class="line">    public final static int NORM_PRIORITY = 5;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The maximum priority that a thread can have.</span><br><span class="line">     */</span><br><span class="line">    public final static int MAX_PRIORITY = 10;</span><br></pre></td></tr></table></figure>

<h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**获取线程上下文的类加载器，也就是这个类由哪个类加载器加载*/</span></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> ClassLoader <span class="title function_">getContextClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (contextClassLoader == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            ClassLoader.checkClassLoaderPermission(contextClassLoader,</span><br><span class="line">                                                   Reflection.getCallerClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> contextClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**设置该线程的类加载器，这个方法打破类加载器的父委托机制，有时候称这个方法是类加载器的后门*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContextClassLoader</span><span class="params">(ClassLoader cl)</span> &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> <span class="title class_">RuntimePermission</span>(<span class="string">&quot;setContextClassLoader&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        contextClassLoader = cl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><h5 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a><code>interrupt()</code></h5><p>中断线程，当线程A运行时，线程B可以调研线程A的interrupt方法设置线程A的中断标志为true，并立即返回。设置标志只是设置标志，线程A实际没有中断，会继续执行。如果线程A因为调用wait系列函数，join方法或者sleep方法被阻塞挂起，这个时候线程B调用线程A的interrupt方法，线程A会在调用这些方法的地方抛出<code>InterruptedException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">            b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a><code>isInterrupted()</code></h5><p>检测当前线程是否被中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isInterrupted(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a><code>interrupted()</code></h5><p>检测当前线程是否被中断，与<code>isInterrupted()</code>的不同之处是，如果该方法发现当前线程被中断，会清除中断标志，该方法是static方法，可以通过Thread类直接调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="literal">true</span>);<span class="comment">//放回当前线程的中断标志，而不是调用interrupted（）方法的实例对象。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从<code>interrupted()</code>和<code>isInterrupted()</code>的源代码中看的他们都调用一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">(<span class="type">boolean</span> ClearInterrupted)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClearInterrupted参数主要控制是否擦除线程interrupt的中断标识。</span></span><br><span class="line"><span class="comment">//false表示不想擦除</span></span><br><span class="line"><span class="comment">//true表示想擦除</span></span><br></pre></td></tr></table></figure>

<h4 id="线程join"><a href="#线程join" class="headerlink" title="线程join"></a>线程join</h4><p>在实际中会遇见需要等待某几件事完成后才能继续往下执行，比如多线程加载资源，需要等待多个线程全部加载完毕再汇总。</p>
<h4 id="关闭线程"><a href="#关闭线程" class="headerlink" title="关闭线程"></a>关闭线程</h4><p>有一个Deprecated方法stop方法，该方法在关闭线程的时候可能不会释放monitor锁，所以不建议使用该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkAccess();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">                security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// A zero status value corresponds to &quot;NEW&quot;, it can&#x27;t change to</span></span><br><span class="line">        <span class="comment">// not-NEW because we hold the lock.</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            resume(); <span class="comment">// Wake up thread if it was suspended; no-op otherwise</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The VM can handle all thread states</span></span><br><span class="line">        stop0(<span class="keyword">new</span> <span class="title class_">ThreadDeath</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">(Throwable obj)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="正常关闭"><a href="#正常关闭" class="headerlink" title="正常关闭"></a>正常关闭</h5><h6 id="线程结束生命周期"><a href="#线程结束生命周期" class="headerlink" title="线程结束生命周期"></a>线程结束生命周期</h6><h6 id="捕获中断信号关闭线程"><a href="#捕获中断信号关闭线程" class="headerlink" title="捕获中断信号关闭线程"></a>捕获中断信号关闭线程</h6><p>借助中断线程的方式使其退出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShutDown</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Start Work&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Stop Work&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;System will be shutdown&quot;</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Start Work</span><br><span class="line">System will be shutdown</span><br><span class="line">Stop Work</span><br></pre></td></tr></table></figure>

<h6 id="使用volatile开关控制"><a href="#使用volatile开关控制" class="headerlink" title="使用volatile开关控制"></a>使用volatile开关控制</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Volatile</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">closed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Start Work&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!closed &amp;&amp; !isInterrupted())&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Stop Work&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.closed = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyTask</span> <span class="variable">myTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>();</span><br><span class="line">        myTask.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;the system will be shutdown&quot;</span>);</span><br><span class="line">        myTask.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">Start Work</span><br><span class="line">the system will be shutdown</span><br><span class="line">Stop Work</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="异常退出"><a href="#异常退出" class="headerlink" title="异常退出"></a>异常退出</h5><p>在一个线程的执行单元中，不允许抛出checked异常，不论Thread的run方法还是Runnable的方法，如果线程在运行过程中需要捕获checked异常并判断是否继续执行，此时可以将checked异常封装为unchecked异常（<code>RuntimeException</code>）抛出结束线程的生命周期。</p>
<h5 id="线程假死"><a href="#线程假死" class="headerlink" title="线程假死"></a>线程假死</h5><p>假死：线程存在，但是没有日志输出不进行任何作业。造成原因是线程死锁。</p>
<h6 id="死锁产生必须具备以下条件："><a href="#死锁产生必须具备以下条件：" class="headerlink" title="死锁产生必须具备以下条件："></a>死锁产生必须具备以下条件：</h6><p>互斥条件：线程对已经获取的资源进行排他性使用也就是该资源同时只能由一个线程占用。如果此时还有其他的线程请求获取该资源，请求者只能等待，直到占用资源的线程释放资源。</p>
<p>请求并持有条件：一个线程已经持有至少一个资源，又提出新的资源请求，新的资源被其他的线程占用，当前的线程被阻塞，但阻塞的同时并没有释放自己已经获取的资源。</p>
<p>不可剥夺条件：线程获取到的资源在自己使用完毕之前不能被其他的线程抢占，只有使用完毕之后才由自己释放资源。</p>
<p>环路等待条件：在发生死锁时，必然存在一个线程资源的环形链<code>&#123;T1,T2,T3……Tn&#125;</code>，T1等待T2，T2等待T3，……Tn等待已经被占用的资源T1。</p>
<h6 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h6><p>破坏至少一个构造死锁的必要条件即可，目前只有请求并持有，环路等待可以被破坏。</p>
<p>造成死锁的原因其实和申请资源的顺序有很大的关系，使用资源申请的有序性原则就可以避免死锁。</p>
<p>加入线程A和线程B都需要资源1,2,3，…… N。对资源进行排序，线程A和线程B只有在获取N-1资源之后才能去获取N资源。</p>
<h3 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h3><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>synchronized关键字提供一种锁的机制，能够确保共享变量的互斥访问，从而防止数据不一致问题。</p>
<p>synchronized关键字包括monitor enter和monitor exit两个JVM指令。</p>
<ul>
<li><p>​	线程执行到monitor enter成功之前必须从主内存中获取数据，不是缓存。</p>
</li>
<li><p>​	在monitor exit成功之后，共享变量被更新后的值必须刷入主内存。</p>
</li>
</ul>
<p>synchronized的指令严格遵守 java happens-before规则，一个monitor exit指令之前必须有一个monitor enter。</p>
<h5 id="synchronized使用注意"><a href="#synchronized使用注意" class="headerlink" title="synchronized使用注意"></a>synchronized使用注意</h5><h6 id="synchronized用于对代码块或方法进行修饰，不能用于class和变量。"><a href="#synchronized用于对代码块或方法进行修饰，不能用于class和变量。" class="headerlink" title="synchronized用于对代码块或方法进行修饰，不能用于class和变量。"></a>synchronized用于对代码块或方法进行修饰，不能用于class和变量。</h6><h6 id="synchronized关联的对象不能为空。"><a href="#synchronized关联的对象不能为空。" class="headerlink" title="synchronized关联的对象不能为空。"></a>synchronized关联的对象不能为空。</h6><h6 id="synchronized作用域太大，影响并发执行的效率。"><a href="#synchronized作用域太大，影响并发执行的效率。" class="headerlink" title="synchronized作用域太大，影响并发执行的效率。"></a>synchronized作用域太大，影响并发执行的效率。</h6><h6 id="不能用不同monitor企图锁相同的方法"><a href="#不能用不同monitor企图锁相同的方法" class="headerlink" title="不能用不同monitor企图锁相同的方法"></a>不能用不同monitor企图锁相同的方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">MUTEX</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span>(MUTEX)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(Task::<span class="keyword">new</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="多个锁的交叉导致死锁"><a href="#多个锁的交叉导致死锁" class="headerlink" title="多个锁的交叉导致死锁"></a>多个锁的交叉导致死锁</h6><h4 id="this-monitor-和-class-monitor"><a href="#this-monitor-和-class-monitor" class="headerlink" title="this monitor 和 class monitor"></a>this monitor 和 class monitor</h4><p>this monitor： 使用synchronized关键字同步 类的不同实例方法，争夺同一个monitor的lock</p>
<p>class monitor：使用synchronized关键字同步 某个类的不同静态方法，争夺同一个monitor的lock</p>
<h3 id="第五章-线程间通信"><a href="#第五章-线程间通信" class="headerlink" title="第五章 线程间通信"></a>第五章 线程间通信</h3><h4 id="wait和sleep"><a href="#wait和sleep" class="headerlink" title="wait和sleep"></a>wait和sleep</h4><ol>
<li>两者都可以使线程进入阻塞状态</li>
<li>都是可中断方法，被中断后会收到中断异常</li>
<li>wait是Object的方法，sleep是Thread特有的方法</li>
<li>wait执行在同步方法中，sleep不需要</li>
<li>执行sleep不会释放monitor锁，wait释放</li>
<li>sleep方法短暂休眠之后主动退出阻塞，wait方法需要被其他线程唤醒</li>
</ol>
<h3 id="第六章锁的概述"><a href="#第六章锁的概述" class="headerlink" title="第六章锁的概述"></a>第六章锁的概述</h3><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易被其他的线程修改，所以在数据被处理前对数据进行加锁，整个处理过程中，数据处于锁定的状态。</p>
<p>乐观锁认为数据在一般情况下不会造成冲突，所以在访问之前不会加排他锁，而是在数据提交更新时才会正式对数据冲突与否进行检测。</p>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>根据线程获取锁的抢占机制，分为公平锁与非公平锁。</p>
<p>公平锁：线程获取锁按照线程请求锁的时间早晚决定。</p>
<p>非公平锁不一定按照请求的时间顺序</p>
<p>在没有公平需求下，使用非公平锁效率较高。</p>
<h4 id="独占锁和共享锁"><a href="#独占锁和共享锁" class="headerlink" title="独占锁和共享锁"></a>独占锁和共享锁</h4><p>根据锁只能被单个线程持有还是多个线程持有分为独占锁和共享锁。</p>
<p>独占锁是悲观锁</p>
<p>共享锁是乐观锁</p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>当一个线程要获取一个呗其他线程持有的独占锁时，该线程会被阻塞，当一个线程再次获取它已经获取的锁是否会被阻塞？如果不阻塞，该锁为可重入锁。只要该线程获取了该锁，可以无限次使用，进入被该锁锁住的代码段。</p>
<p>synchronized内部锁是可重入锁。</p>
<p>可重入锁的原理是锁的内部维护一个线程标示，标示该锁被哪几个线程占用，然后关联一个计数器，初始值为0，当一个线程获取了该锁，计数器+1当其他线程要来获取该锁会发现该锁的所有者不是自己而阻塞挂起。当线程再次访问自己持有的该锁就会把计数器+1，释放-1。当锁计数值为0锁的线程标示也重置null，被阻塞的线程就会被唤醒竞争该锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>当线程获取锁失败后，会被切换到用户状态而被挂起，当线程获到取该锁时有需要切换到内核状态而唤醒该线程。从用户状态切换到内核状态开销较大，一定程度上影响并发性能。</p>
<p>自旋锁是在当前线程获取锁时，如果被其他线程占用，不马上阻塞自己在不放弃cpu使用权的情况下，多次尝试获取，可能几次尝试后该锁被其他线程释放，指定次数后仍没有获取该锁，则该线程被阻塞挂起。</p>
<p>自旋锁使用CPU时间换取线程阻塞与调度的开销。</p>
<h3 id="第八章线程池"><a href="#第八章线程池" class="headerlink" title="第八章线程池"></a>第八章线程池</h3><h2 id="第二部分-Java-ClassLoader"><a href="#第二部分-Java-ClassLoader" class="headerlink" title="第二部分 Java ClassLoader"></a>第二部分 <code>Java ClassLoader</code></h2><h3 id="第九章-类的加载过程"><a href="#第九章-类的加载过程" class="headerlink" title="第九章 类的加载过程"></a>第九章 类的加载过程</h3><h4 id="类的主动使用和被动使用"><a href="#类的主动使用和被动使用" class="headerlink" title="类的主动使用和被动使用"></a>类的主动使用和被动使用</h4><h5 id="六种主动使用会导致类的初始化："><a href="#六种主动使用会导致类的初始化：" class="headerlink" title="六种主动使用会导致类的初始化："></a>六种主动使用会导致类的初始化：</h5><ol>
<li>new关键字导致的初始化</li>
<li>访问类的静态变量</li>
<li>访问类的静态方法</li>
<li>初始化子类导致父类的初始化</li>
<li>启动类(main方法所在的类)</li>
<li>对某个类进行反射操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class.forName(<span class="string">&quot;chapter9.Child&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\面试\springbootimages\1570885255358.png" alt="1570885255358"></p>
<h5 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h5><ol>
<li><p>用new新建一个类的数组不是主动使用，不会导致类的初始化。该操作只是在堆内存中开辟一定的地址空间<img src="D:\面试\springbootimages\1570885543981.png" alt="1570885543981"></p>
</li>
<li><p>引用类的静态常量不会导致类的初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalConstants</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;the globalConstants will be initialized!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span><span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">       </span><br><span class="line">       System.out.println(GlobalConstants.random);</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\面试\springbootimages\1570886197895.png" alt="1570886197895"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">   </span><br><span class="line">       System.out.println(GlobalConstants.max);</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\面试\springbootimages\1570886138448.png" alt="1570886138448"></p>
<p>max是静态常量在其他的类中可以直接访问不用类初始化，但是在其他类访问random时会导致类的初始化，由于random需要进行随机数字计算，在类的加载、连接阶段无法计算，只有进行初始化后才能对其赋予准确的值。</p>
</li>
</ol>
<h4 id="类的加载过程分为三个阶段："><a href="#类的加载过程分为三个阶段：" class="headerlink" title="类的加载过程分为三个阶段："></a>类的加载过程分为三个阶段：</h4><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><p>class文件中的二进制数据读取到内存</p>
<p>将该字节流代表的静态存储结构转换为方法区运行时的数据结构</p>
<p>在堆内存中生成<code>java.lang.Class</code>对象作为访问方法区这个类的各个数据的入口</p>
<h5 id="连接阶段"><a href="#连接阶段" class="headerlink" title="连接阶段"></a>连接阶段</h5><h6 id="连接阶段又分为：验证、准备、解析"><a href="#连接阶段又分为：验证、准备、解析" class="headerlink" title="连接阶段又分为：验证、准备、解析"></a>连接阶段又分为：验证、准备、解析</h6><ol>
<li><p>验证</p>
<p>验证class文件字节流包含的内容符合当前JVM的规范要求，不会危害JVM自身的代码。当字节流不符合要求，抛出<code>VerifyError</code>异常或者子异常。</p>
<ul>
<li>验证文件格式</li>
</ul>
<p>​	文件头部魔术因子</p>
<p>​	主次版本号</p>
<p>​	构成class文件的字节流书否存在残缺或者附加信息</p>
<p>​	常量池中常量是否存在不被支持的数据类型</p>
<p>​	指向常量中的引用是否指到了不存在的常量或者常量类型不支持</p>
<p>​	class文件各个部分及文件本身是否有被删除或者附加的其他信息</p>
<p>​	……</p>
<ul>
<li>元数据验证：对字节流进行语义分析，符合JVM规范要求，符合Java语言规范。</li>
</ul>
<p>​	这个类是否有父类（除了Object之外，其他的类都有父类）</p>
<p>​	这个类是否继承了不允许继承的类</p>
<p>​	这个类不是抽象类是不是实现了接口或者其父类要求实现的所有方法</p>
<p>​	……</p>
<ul>
<li>字节码验证：验证程序控制流程（循环、分支）</li>
</ul>
<p>​		程序计数器指令不会跳到不合法的字节码指令中</p>
<p>​		类型转换合法</p>
<p>​		虚拟机栈中的操作栈类型和指令代码都可以正确的被执行</p>
<ul>
<li><p>符号引用验证：符号引用转换为直接引用时的合法性</p>
<p>符号引用通过全限定名称是否能找到对应的类。</p>
<p>指定的类是否存在符合方法的字段描述以及简单名称所描述的字段和方法</p>
<p>符号引用中的类是否可以被当前类访问</p>
</li>
</ul>
</li>
<li><p>准备</p>
<p>对类的静态变量分配内存（在方法区分配，只是类变量），并为其给定一个没有初始值的默认值。</p>
<p>一般情况下初始化默认值为零值，但是如果字段final，那么会在javac编译时生成ConstantValue属性值，虚拟机就会根据该属性设置这个字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedPrepare</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在准备阶段 a变量初始值为0，b变量初始值为5。</p>
<p>final static 静态常量在类的编译过程中javac会将其value生成一个ConstantValue属性直接赋值为5</p>
</li>
<li><p>解析</p>
<p>在常量池中寻找类、接口、字段和方法的符号引用，并将其符号引用替换为直接引用</p>
<p><strong>符号引用和直接引用的关联</strong>：</p>
<ol>
<li>​	符号引用：以一组符号来描述引用目标，可以是任何字面量，只要可以无歧义的定位目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标不一定已经加载在内存中。各种虚拟机实现的内存布局可以各不相同，但是它们接收的符号引用必须是一致的。</li>
<li>直接引用：是可以直接指向目标的指针，相对偏移量或者一个可以间接定位到目标的句柄。直接引用和虚拟机实现的内存布局相关，同一个符号引用在不同的虚拟机上翻译出来的直接引用一般不会相同。有了直接引用，那么这些数据一定在内存中。</li>
</ol>
</li>
</ol>
<h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><p>最重要的事情执行<clinit>方法，在<clinit>方法中所有的类变量都赋予正确的值（程序中编写的值）</p>
<p><clinit>方法和类的构造函数有所不同，不需要显示的调用父类的构造器，虚拟机会保证父类的<clinit>方法先被执行，所以父类的静态变量优先被赋值。</p>
<p><font style="color:red">如果类中没有static块，static变量，static方法就不会生成<clinit>方法。</font></p>
<p>多线程访问<clinit>方法可以保证只能有一个线程执行到static部分并且只执行一次，JVM保证了<clinit>方法在多线程执行的环境下同步。</p>
<p><img src="D:\面试\springbootimages\1570892821268.png" alt="1570892821268"></p>
<p><img src="D:\面试\springbootimages\1570892866845.png" alt="1570892866845"></p>
<p><strong>在类加载的整个生命周期中，各个阶段可以交叉进行。但是从总体上看各个阶段的顺序还是加载，连接，初始化。</strong></p>
<h3 id="第十章-JVM类加载器"><a href="#第十章-JVM类加载器" class="headerlink" title="第十章 JVM类加载器"></a>第十章 JVM类加载器</h3><h4 id="JVM内置的三大加载器"><a href="#JVM内置的三大加载器" class="headerlink" title="JVM内置的三大加载器"></a>JVM内置的三大加载器</h4><h5 id="根类加载器（Bootstrap类加载器）"><a href="#根类加载器（Bootstrap类加载器）" class="headerlink" title="根类加载器（Bootstrap类加载器）"></a>根类加载器（Bootstrap类加载器）</h5><p>最顶层的类加载器，主要负责核心类库的加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bootstrap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String.class的类加载器就是根类加载器，但是根类加载器不能获得引用所以输出为null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bootstrap:&quot;</span>+String.class.getClassLoader());</span><br><span class="line">        <span class="comment">//sun.boot.class.path获取根加载器加载路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;sun.boot.class.path&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bootstrap:null<br>D:\Program Files\Java\jdk1.8.0_221\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\sunrsasign.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_221\jre\classes</p>
<p>Process finished with exit code 0</p>
<h5 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h5><p>通过java.ext.dir获取扩展类加载器的加载资源的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</p>
<p>Process finished with exit code 0</p>
<p><font color="red">如果将自己类的jar包放在扩展类加载器所在的路径下，扩展类加载器会负责加载所需要的类</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; helloClass = Class.forName(<span class="string">&quot;chapter10.Hello&quot;</span>);</span><br><span class="line">        System.out.println(helloClass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sun.misc.Launcher$ExtClassLoader@7f31245a</p>
<p>Process finished with exit code 0</p>
<h5 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h5><p>最常见的类加载器，主要负责加载classpath下的类库资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        System.out.println(ApplicationClassLoader.class.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>D:\Program Files\Java\jdk1.8.0_221\jre\lib\charsets.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\deploy.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\access-bridge-64.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\cldrdata.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\dnsns.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\jaccess.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\jfxrt.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\localedata.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\nashorn.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunec.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunjce_provider.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunmscapi.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\sunpkcs11.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\ext\zipfs.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\javaws.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jce.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jfr.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jfxswt.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\jsse.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\management-agent.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\plugin.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\resources.jar;D:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar;D:\myCode\JavaTest\ConCurrency\out\production\Concurrency;D:\Program Files\JetBrains\IntelliJ IDEA 2019.2.1\lib\idea_rt.jar<br>sun.misc.Launcher$AppClassLoader@18b4aac2</p>
<p>Process finished with exit code 0</p>
<h5 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Path</span>  <span class="variable">DEFAULT_CLASS_DIR</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;F:&quot;</span>, <span class="string">&quot;classLoaderDir1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(Path classDir)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classDir = classDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classDir)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent, String classDir)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.classDir = Paths.get(classDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] classBytes = <span class="built_in">this</span>.readClassBytes(name);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == classBytes || classBytes.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Can not load the class &quot;</span>+ name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用defineClass方法定义class</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] readClassBytes(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//包分隔符转换为文件分隔符</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> name.replace(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">classFullPath</span> <span class="operator">=</span> classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (!classFullPath.toFile().exists())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;the class &quot;</span> + name +<span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将class文件读取到内存中</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">bao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>())&#123;</span><br><span class="line">            Files.copy(classFullPath, bao);</span><br><span class="line">            <span class="keyword">return</span> bao.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;load the class &quot;</span>+ name +<span class="string">&quot; occur error.&quot;</span>, e );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My Class Loader.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="双亲委派模型工作过程："><a href="#双亲委派模型工作过程：" class="headerlink" title="双亲委派模型工作过程："></a>双亲委派模型工作过程：</h5><p>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都会传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成这个请求，子类加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型一个好处就是Java类会随着它的加载器具备一种带有优先级的层次关系。例如java.lang.Object这个类存放在rt.jar中，无论哪一个类加载器要加载这个类，最终会委派给启动类加载器进行加载，因此这个类在程序中各个类加载环境下都是一个类。</p>
<p>如果没有使用双亲委派模型，由各个类加载器自行加载将会产生多个不同的类。这样会造成程序混乱。所以双亲委派模型保证Java程序稳定运行。</p>
<h6 id="全路径格式"><a href="#全路径格式" class="headerlink" title="全路径格式"></a>全路径格式</h6><ul>
<li>包名.类名</li>
<li>包名.类名$内部类</li>
<li>包名.类名$内部类$内部类$匿名内部类</li>
<li>包名.类名$匿名内部类$匿名内部类</li>
</ul>
<h4 id="类加载器的命名空间"><a href="#类加载器的命名空间" class="headerlink" title="类加载器的命名空间"></a>类加载器的命名空间</h4><p>每个类加载器的命名空间是由该加载器和所有父加载器所构成的，每一个类加载器中同一个class是为一个。</p>
<p><strong>但是使用不同的类加载器或者同一个加载器的不同实例家在同一个class会在堆内存和方法区产生多个class对象。</strong></p>
<p>因此同一个class在JVM中存在一个的说法不够严谨，准确的说同一个class在同一个类的加载器命名空间是唯一的。</p>
<h4 id="类加载器的运行时包"><a href="#类加载器的运行时包" class="headerlink" title="类加载器的运行时包"></a>类加载器的运行时包</h4><p>包的作用是为了组织类，防止不同包下相同名称的class引起冲突。</p>
<p>起到封装作用，包名和类名构成类的全限定名称。</p>
<p><strong>JVM运行时class有一个运行时包，由类加载器的命名空间和类的全限定名称组成。</strong></p>
<p>JVM规定不同的运行包下类之间不可以进行访问</p>
<h4 id="初始类加载器"><a href="#初始类加载器" class="headerlink" title="初始类加载器"></a>初始类加载器</h4><p>每个类在经过<code>ClassLoader</code>加载后会在虚拟机中有对应的Class实例，如果某个类被某个类加载器加载，这个类加载器就是该类的初始类加载器。</p>
<p>每个类加载器维护一个列表，记录将该类加载器作为初始类加载器的所有class，JVM使用这些列表判断类是否已经加载过，是否需要首次加载。</p>
<p>在JVM规范中，在类的加载过程中，所有参与的类加载器即使没有亲自加载过一个类，也都会被表示为该类的初始类加载器。因此有些时候代码中自定义的类加载器加载的类可以访问根加载器，扩展加载器和系统加载器加载的class。</p>
<h4 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h4><p>垃圾回收线程进行GC回收。</p>
<p>满足三个条件的时候才能被回收：</p>
<ol>
<li>该类的实例已经被GC</li>
<li>加载该类的<code>classLoader</code>实例被回收</li>
<li>该类的class实例没有在其他地方的引用</li>
</ol>
<h3 id="第十一章线程上下文类加载器"><a href="#第十一章线程上下文类加载器" class="headerlink" title="第十一章线程上下文类加载器"></a>第十一章线程上下文类加载器</h3><p>上下文类加载器的作用：</p>
<p>JDK定义核心的SPI的标准接口使用根类加载器加载，而第三方厂商提供的类驱动由系统类加载器加载，由于JVM类加载器的双亲委派机制，根类加载器不会加载第三方的实现，为了解决这个问题提供了线程上下文类加载器，反父委托，需要委托子类加载器加载。</p>
<h2 id="第三部分-Java并发包JUC"><a href="#第三部分-Java并发包JUC" class="headerlink" title="第三部分 Java并发包JUC"></a>第三部分 Java并发包JUC</h2><h3 id="锁原理剖析"><a href="#锁原理剖析" class="headerlink" title="锁原理剖析"></a>锁原理剖析</h3><h4 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a><code>LockSupport</code>工具类</h4><p>rt.jar包中的<code>LockSupport</code>工具类，主要用于唤醒和挂起线程。<code>LockSupport</code>工具类工具类为每个线程关联一个许可证。</p>
<ol>
<li><p>park()方法</p>
<p>如果调用park（）方法的线程已经拿到与<code>LockSupport</code>工具类关联的许可证，调用该方法马上返回，否则会被挂起禁止参与线程调度。</p>
</li>
<li><pre><code class="java">public static void unpark(Thread thread) &#123;
        if (thread != null)
            UNSAFE.unpark(thread);
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   调用该方法，如果线程没有持有许可证，该方法会让其持有。</span><br><span class="line"></span><br><span class="line">   如果该线程调用park（）方法被挂起，调用unpark会将该线程唤醒。</span><br><span class="line"></span><br><span class="line">   如果之前没有调用过park（）方法，调用unpark（）方法之后调用park（）方法会立刻返回。</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">3. ```java</span><br><span class="line">   public static void parkNanos(long nanos) &#123;</span><br><span class="line">           if (nanos &gt; 0)</span><br><span class="line">               UNSAFE.park(false, nanos);</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

线程调用该方法时关联到许可证，可以立即返回，如果被挂起将会在nanos时间之后自动返回。
</code></pre>
</li>
<li><pre><code class="java">public static void parkNanos(Object blocker, long nanos) &#123;
        if (nanos &gt; 0) &#123;
            Thread t = Thread.currentThread();
            setBlocker(t, blocker);
            UNSAFE.park(false, nanos);
            setBlocker(t, null);
        &#125;
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   不同之处加上blocker，当线程没有许可证被挂起，blocker对象会被记录到线程内部，使用诊断工具获取blocker对象观察线程阻塞原因。</span><br><span class="line"></span><br><span class="line">### CAS机制</span><br><span class="line"></span><br><span class="line">比较并交换是原子操作的一种，可用于在多线程编程中实现不被打断的数据交换操作。避免多线程同时改写某一数据时，由于执行顺序不确定性以及中断的不可预见性产生数据的不一致问题。**该操作通过将内存的值与指定数据进行比较，当数值一样时将内存的数据替换为新的数据**。</span><br><span class="line"></span><br><span class="line">乐观锁：每次不加锁，假设修改数据之前，其他的线程都不会修改，如果修改过就会产生冲突失败重试，直到成功为止。</span><br><span class="line"></span><br><span class="line">CAS是一种乐观锁的实现。</span><br><span class="line"></span><br><span class="line">CAS操作包含三个操作数：内存地址，旧的预期值，即将要更新的新值。执行CAS操作的时候，将内存位置的值与原值比较，如果相匹配就会将该位置值更新为新值，否则就不做任何操作。</span><br><span class="line"></span><br><span class="line">#### 自增自减问题</span><br><span class="line"></span><br><span class="line">volatile关键字主要保证**禁止指令重拍**和**保证可见性**，但是不保证原子性。</span><br><span class="line"></span><br><span class="line">n++被拆分成：</span><br><span class="line"></span><br><span class="line">1. 执行getfield拿到原始n</span><br><span class="line">2. 执行iadd进行加1操作</span><br><span class="line">3. 执行putfield把累加的值写会n</span><br><span class="line"></span><br><span class="line">由于volatile可以保证线程之间的可见性但是n++不是一个指令操作，volatile不能保证该操作的原子执行，在多线程并发执行下无法做到线程安全。</span><br><span class="line"></span><br><span class="line">##### JDK原子变量类</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image-20191105133722679](D:\面试\springbootimages\image-20191105133722679.png)</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Cases &#123;</span><br><span class="line">    public static AtomicInteger count = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    public static void add()&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String [] args) throws InterruptedException &#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            service.execute(() -&gt;&#123;</span><br><span class="line">                for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">        service.awaitTermination(1, TimeUnit.DAYS);</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cases</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    add();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">        service.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS缺陷"><a href="#CAS缺陷" class="headerlink" title="CAS缺陷"></a>CAS缺陷</h4><h5 id="循环时间长开销大，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。"><a href="#循环时间长开销大，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。" class="headerlink" title="循环时间长开销大，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。"></a>循环时间长开销大，自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</h5><h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>​	解决方案：1.用锁 2.把多个共享变量合并成一个共享变量来操作。</p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>​	如果内存地址V初次读取的值为A，在准备赋值的时候检查他的值是否仍然是A，<strong>但是不能确定它的值没有被其他的线程改变过</strong>。这段时间期间它的值被改为B，又被改为A，但是CAS会误认为它没有改变过，这个漏洞称为ABA问题。</p>
<p><code>AtomicStampedReference</code>来解决ABA问题，类中的<code>compareAndSet</code>方法作用首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果相等，以原子方式将该引用和标记的值设置为给定的更新值。</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2023/01/25/Linux%E6%80%BB%E7%BB%93/">prev</a>
    

    
    <p>last update time 2023-08-05</p>
    
    
        <a class="extend next post-next" href="/2022/10/25/Spring%20Boot/">next</a>
    
    </div>


    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © 洪志鑫 2022 - 2023
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
